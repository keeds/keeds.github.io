<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>keeds.github.io - datomic, functions and expectations</title>
        <link rel="stylesheet" type="text/css" href="../css/base.css" />
        <link rel="stylesheet" type="text/css" href="../css/syntax.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">keeds.github.io</a>
            </div>
            <div id="navigation" class="right">
                <a href="../about.html">about</a>
                <a href="../contact.html">contact</a>
                <a href="../archive.html">archive</a>
            </div>
        </div>

        <div id="content">
          <h1>datomic, functions and expectations</h1>

            <div class="info">
    Posted on May  8, 2014
    
</div>

<p>Bare in mind the usual disclaimer that none of this is revelatory. Just a dump of what I’ve done in the hope that it helps me make sense of it.</p>
<p>This post was prompted by Tim Crayford’s post <a href="http://yellerapp.com/posts/2014-05-07-testing-datomic.html">Testing Against Datomic</a>. Although I can imagine that most people using Datomic would do such a thing, there does not appear to be much content around about how? So here’s my two-penneth.</p>
<p>Anyway… <a href="http://clojure.org/">Clojure</a>, <a href="http://www.datomic.com/">Datomic</a> and testing. It’s always (for me) been hard to test SQL database schemas and functions. One of the features about Datomic is that it separates (decomplects?) the query handling and the transaction handling from each other and the underlying datastore. This means you can use a variety of types datastores and change as needs arises. It also allows for an in memory database which is ideal for testing.</p>
<p>We generally use <a href="http://jayfields.com/expectations/">Expectations</a> for our test framework. It’s small and simple. Anyway to test the schema and any database functions you can do this.</p>
<pre class="sourceCode Clojure"><code class="sourceCode clojure">(<span class="kw">def</span><span class="fu"> db-uri </span><span class="st">&quot;datomic:mem://db&quot;</span>)

(<span class="kw">defn</span><span class="fu"> setup</span>
  {<span class="kw">:expectations-options</span> <span class="kw">:before-run</span>}
  []
  (drop-database! db-uri)
  (db-init db-uri)
  (<span class="kw">let</span> [db (d/db (d/connect db-uri))]
    (<span class="kw">def</span><span class="fu"> test-db  </span>db)
    (<span class="kw">def</span><span class="fu"> func1 </span>(<span class="kw">-&gt;</span> (d/entity db <span class="kw">:func1</span>) <span class="kw">:db</span>/fn))
    (<span class="kw">def</span><span class="fu"> func2 </span>(<span class="kw">-&gt;</span> (d/entity db <span class="kw">:func2</span>) <span class="kw">:db</span>/fn))))</code></pre>
<p>(setup) with the :expectations-options metadata is a function that is run every time expectations loads the namespace.</p>
<p>(db-init …) simply does a create-database, transacts the schema, transacts the database functions. All this done in the mearest of moments in memory.</p>
<p>The test-db var gives you access to an initialised database that combined with the datomic (with) function and the :db-after returned value allows you test whatever transactions and database functions without having to pull down and recreate a database.</p>
<p>The func1, func2 vars enable you to directly call your stored datomic database functions in your code. They might be simple validation functions that check the input and return it or an Exception if invalid. They might create transaction data for consistent entities. You can test the transaction data without transacting it. It’s just data. Or you can test the result of the transaction using the returned :tempids to query the entity that should have been created.</p>
<pre class="sourceCode Clojure"><code class="sourceCode clojure">(expect RuntimeException (func1 {}))
(expect {<span class="kw">:book</span>/title <span class="st">&quot;Clojure rocks&quot;</span>} (func1 {<span class="kw">:book</span>/title <span class="st">&quot;Clojure rocks&quot;</span>}))</code></pre>
<p>So combine this with <a href="https://github.com/jakemcc/lein-autoexpect">lein autoexpect</a> you are all set to TDD (if that’s your bag) your schema and database functions to your hearts content.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
